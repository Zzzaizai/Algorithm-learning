cpp的内存分区
- 栈，主要存放局部变量、函数参数以及返回地址等，操作系统进行默认分配空间并回收，生命周期与进程周期相同。
- 堆，存放动态变量，malloc和new动态申请的内存，free和delete控制释放，当进程结束，操作系统自动回收。
- 全局区/静态存储区，存放全局变量和静态变量，操作系统自动释放。
- 常量存储区，存放常量，只读。
- 代码区，存放代码，只读。编译后的二进制存放在这里。

栈与堆对比
- 操作系统为每个进程固定栈的大小，栈顶有一个特殊内存页guard，当越界访问guard会出现栈溢出错误。
- 堆由程序申请和释放，对于堆的动态内存管理很复杂，有许多技巧处理。
- 栈在内存中是一块连续的区域，只能被当前进程访问，栈空间一般较小，分配效率高，但无法控制。
- 堆在内存中以链表呈现。分配效率低，易产生碎片。

变量与生命周期
- 全局变量，全局定义，可在其他源文件里访问，只需external声明。生命周期贯穿于整个程序运行期间。
- 静态全局变量，当前源文件全局可用。生命周期贯穿于整个程序运行期间。
- 局部变量，实际是以{}为作用域。函数调用结束就销毁。
- 静态局部变量，具有局部作用域，只被初始化一次，然后至程序结束一直存在，但只对定义自己的函数体可见。生命周期贯穿于整个程序运行期间。
- 此外，全局变量的定义不要在头文件中进行，否则被多个文件include时，全局变量就会被定义多次，出错。

内存对齐
- cpu访问内存以机器字长为单位，由数据总线宽决定。
- 编译器将每个数据单元的地址安排在机器字节整数倍的地址指向的内存中，以减少访问内存的次数。
- 大部分内存对齐由编译器处理，会在内存之间填充字节，结构体的内存对齐由最宽的基本类型成员决定或对其基数决定，如有需要会在结构体末尾成员后添加填充字节。
- 可以使用```#progma pack(x)```指定结构体以x为单位对齐。

智能指针
- 传统指针需用free或delete释放，容易产生内存泄漏，智能指针创建时分配相应内存，对象销毁时析构函数自动释放内存，但智能指针不支持加减运算。
- unique_ptr，独享所有权的智能指针，资源只被一个指针占有，不能拷贝构造和赋值，但可以移动构造和移动赋值构造，即一个指针对象赋值给另一个指针对象。
- shared_ptr，指针中的资源可被多个指针共享，但多指针指向同一资源时不能被多次释放，因此使用计数机制，计数为0自动释放内存。shared_ptr不是线程安全的。
- weak_ptr，指向shared_ptr指向的对象，可以解决循环引用问题（如p1指向p2，p2又指向p1）。当weak_ptr转为shared_ptr时，虽能访问资源但不享有所有权，不影响计数，有可能资源已被释放，但weak_ptr仍然存在，而shared_ptr需要等待所有引用的weak_ptr都释放后才释放。
- std::make_shared与std::shared_ptr，前者进行一次性内存分配（对象与控制块），避免内存碎片化且保证异常出现时不会泄露内存，后者进行两次内存分配，且两次内存分配之间若抛出异常会造成内存泄漏。对于大型对象的场景，前者会导致长时间占用大块内存，而后者由于对象与控制块分离，可更早释放内存。对于频繁复制场景，前者会更高效。

编译与链接
- 主要将.cpp文件翻译为ELF文件，主要有四个过程：编译预处理、编译、汇编、链接。
- 编译预处理，主要处理代码中预处理指令，去除注释从，处理条件编译，替换宏等。
- 编译，语法语义分析等，对特定cpu进行优化，翻译成.s汇编代码。
- 汇编，将.s翻译为.o机器指令文件，一个.cpp文件对应一个.o文件。
- 链接，单个.o文件可能无法运行，需将多个.cpp文件的.o文件链接，获将库文件中的函数链接起来，从而生成可悲操作系统加载执行的ELF文件。

动态链接与静态链接
- 静态链接，将程序所用的全部外部函数拷贝到可执行程序文件中。
- 动态链接（.so/.dll），程序所调用的部分放到动态链接库中，ELF文件中不包含这些调用程序，当需要调用时，操作系统将动态链接库加载进来。
- 静态链接库浪费控件，每次更新需重新编译链接，但运行速度快。动态链接库节省内存，更新方便，但有性能损失。静态链接由连接器完成，动态链接由操作系统完成。

大端与小端
- 将一个多位数低位放在较小地址处，高位放在较大地址处成为小端序，反之为大端序。
- 小端序在变量指针转换时地址不变。x86为小端序。
- 大端序看起来直观，常用于网络字节序。
- 可用宏定义```__BYTE_ORDER```或```#include<bits/endian.h>```来检测字节序。

内存泄漏
- 指在堆中申请的内存没有及时释放，导致可用内存越来越少。
- 当使用malloc、calloc、realloc和new分配内存后，使用free和delete释放。
- 许多语言带有GC程序，会自动对不使用的内存回收。C/CPP没有。

内存泄漏检测与预防
- valgrind内存检测工具。
- 读写字节时，检查对应的Valid-Address表中对应的bit，若该bit为无效位置，则报告读写错误。
- 当寄存器中的值被用来产生内存地址，或该值影响程序输出，则Memcheck会检查Valid-Value表对应的bits，若尚未初始化，则报告使用未初始化内存错误。
- 也可将内存的分配与释放封装到类中，但类的对象复制时，对指针只会复制地址，所以会对内存释放两次，因此可再增加计数机制或使用深拷贝。或使用智能指针。
- 需养成良好代码习惯，内存申请释放一一对应，将基类析构函数定义为虚函数等（多态），尽可能使用智能指针等。

include
- ```#include<filename>```用于添加标准库头文件，会先从IDE预先指定的搜索目录搜索。
- ```#include "filename"```用于添加自定义头文件，会先从源文件所在目录搜索，如果没有再到系统目录和预先指定的搜索目录中查找。
- ```__has_include```用于检查是否包含了某个文件。









