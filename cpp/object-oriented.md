三大特性
- 继承，子类继承父类的非private成员变量和成员函数，若被final修饰则不能继承。
- 封装，将具体实现过程与数据封装成一个函数，只提供接口访问。
- 多态，动态决定调用哪个派生类的实现，一般使用虚函数实现。

重写、重载、隐藏
- 重载指的是同一可访问区内被声明几个具有不同参数的同名函数，根据参数决定调用哪个函数，不关心函数返回类型。
- 隐藏是指派生类的函数屏蔽了与其同名的基类函数，不管参数列表是否相同，基类函数都会被隐藏。可通过类型名知名访问基类函数。
- 重写指的是派生类存在重新定义的函数，函数名、参数列表、返回值类型必须与基类里被重写的函数一样，基类中被重写的函数必须有virtual修饰。
- 重写可以实现多态，隐藏不可以。

多态实现
- 基类函数前加上virtual修饰，在派生类中重写该函数，运行时将会根据对象的类型调用相应函数。
- 创建一个类时，该对象有一个指向虚函数表的虚表指针vptr，当基类指针指向派生类对象，基类指针调用虚函数时，该基类指针的虚表指针实际指向派生类的虚函数表。与this指针不同，this指针是编译器解析自引用的函数参数，vptr是一个真正的指针。
- 每个使用虚函数的类都有自己的虚函数表，编译器在编译时将其设置为静态数组vtable，此表中每个条目是一个函数指针。
- 如果未使用虚函数，则是普通的隐藏，则基类指针指向派生类对象时，使用的是基类的方法（与指针类型看齐）。

虚函数与纯虚函数
- 纯虚函数在类中声明时，用virtual修饰并加上=0，且没有函数的具体实现。
- 含有纯虚函数的类为抽象类。类中只有接口定义，没有实现。继承纯虚函数的派生类若没有实现基类中的纯虚函数，该派生类依然为抽象类，无法实例化对象，但可以声明抽象类指针与引用。
- 纯虚函数的意义在于让所有类的对象都可以要求实现纯虚函数。
- 析构函数最好定义为虚函数，否则当基类指针指向派生类对象时，对基类指针进行delete操作，只会调用基类的析构函数，造成内存泄漏。构造函数不能为虚函数，因为对象创建后才会产生虚表指针，才能调用虚函数。
- static函数不能定义为虚函数。

多重继承
- 多重继承容易产生命名冲突和数据冗余等问题，如菱形继承中就会产生命名冲突。
- 可以通过显示声明冲突的成员来自于哪个类来解决，也可通过虚继承的方法来解决。
- java、c#、php等语言都不支持多继承。

深拷贝与浅拷贝
- 如果一个类拥有资源，该类的对象复制时，如果资源重新分配就是深拷贝，否则就是浅拷贝。
- 该对象和原对象占用不同的内存，拷贝栈与堆中的内容，就是深拷贝；该对象和原对象占用一块内存，仅拷贝栈中的内容，就是浅拷贝。
- 当类中成员变量有指针时，最好使用深拷贝，因为当两个对象指向同一块内存，如果使用浅拷贝，其中一个对象删除后，该内存就被释放，另一个对象指向的就是垃圾内存。
- 编译器生成的默认拷贝函数大部分是浅拷贝，在特定场景下需要禁止编译器生成默认拷贝构造函数。

虚函数表结构
- 虚函数按照声明顺序放在虚函数表里，父类的虚函数放在子类的虚函数前。
- 单继承且在子类中对父类的虚函数重写时，表的顺序不变，将原本基类的函数替换为子类重写后的函数。
- 多继承且没有虚函数覆盖时，子类的对象将有多个虚表指针，每个指针对应一个父类及其虚函数表。子类自己的虚函数放在第一个指针指向的虚函数表中。
- 多继承且子类对父类的虚函数重写时，同样有多指针指向多张表，并将原本基类的函数替换为重写后的函数。子类自己的虚函数放在第一个指针指向的虚函数表中。

构造函数
- 使用delete可以禁止构造函数使用，使用default可以使用默认构造函数，默认情况下，编译器都会为类生成一个公有的默认构造函数。
- 在构造函数时使用初始化列表可以减少构造函数的开销，因为使用初始化列表会省去调用默认构造函数的过程
- 构造函数的调用顺序为：按照继承顺序，优先虚继承，然后按照派生类中成员变量声明顺序，依次调用该变量所属类的构造函数，最后调用派生类自身构造函数。
- 成员变量的初始化顺序与其在类中声明的顺序一致，和在初始化列表中的顺序无关。
- 类成员在定义时不能初始化，const成员常量必须在初始化列表中初始化，static成员变量必须在类外初始化。

友元
- 友元提供不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。
- 普通函数定义为类的友元函数，则普通函数可以访问该类的private和protected成员。
- 类声明为另一个类的友元类，则可访问其private与protected成员变量。
- 友元不可传递，单向有效。

动态绑定与静态绑定
- 静态绑定是指函数的调用在编译时就决定了调用哪个版本的函数，效率高，适用于普通函数、非虚函数、重载函数。
- 动态绑定是指函数的调用在运行时根据对象的实际类型决定调用哪个版本的函数，利用虚函数机制实现，是实现多态的基础。
- 动态绑定为运行时多态，而编译时多态用模板、函数重载等泛型编程来实现。

模板编程
- 模板允许函数和类使用泛型类型进行操作，模板是泛型编程的基础。库容器如迭代器是泛型编程的例子。
- 函数模板，声明格式为```template<typename identifier> declaration;```。
- 类模板，通常用于实现容器。
- 变量模板，使用变量模板时必须显式指定它的类型。
- 模板与重载都体现了面向对象的多态特性，当多个函数执行相似但不相同的操作时，应使用重载；当多个函数执行的操作相同时，使用模板。

避免拷贝的方法
- 将类的拷贝构造函数和赋值运算符重载为私有，但对于类的成员函数和友元函数依然可以调用。
- 将类的拷贝构造函数和赋值运算符重载为私有，派生类以私有方式继承基类。
- 使用delete禁用拷贝构造函数和赋值运算符。

拷贝构造函数
- 拷贝构造函数的形参必须为引用，避免拷贝构造函数无限制递归导致栈溢出。
- 调用拷贝构造函数的情况：用一个对象初始化另一个对象时，函数参数按值传递时，函数返回对象时，STL容器拷贝元素且没有移动构造时。

禁止类被实例化
- 类中定义纯虚函数。
- 所有构造函数声明为private。
- 将类的所有构造函数用delete修饰。

对象实例化过程
- 分配空间。
- 初始化，不同于赋值。初始化列表执行的是初始化过程。
- 赋值，一般发生在构造函数体内。
- 对于拥有虚函数的类的对象，还需给虚表指针赋值。若无继承关系，则该过程发生在内存分配后；若有继承关系，则分配内存后，先进性基类构造，再给派生类虚表指针赋值，最后进行初始化与赋值。

const/mutable
- const可以确保类的成员函数不能修改成员变量。
- 而被mutable修饰的变量将永远处于可变状态，即使在const函数中。
- mutable只能作用于类的非静态和非常量数据成员。在一个类中应避免大量使用mutable。

对象创建在堆/栈上
- 对象的静态建立，由编译器为对象在栈上分配内存，直接调用构造函数。
- 对象的动态建立，使用new在堆上创建对象，底层调用operate new()函数，然后调用构造函数。
- 限制对象只创建在堆上，可以将类的析构函数设置为私有，编译器会对类的非静态函数检查访问性，检查到析构函数为私有时，就不会在栈上分配内存。但此时若用new创建对象，delete销毁对象，外部无法调用析构函数，因此类内必须定义destory函数来释放new出来的对象；若作为基类析构函数为虚函数，派生类中重写析构函数时无法访问基类的析构函数。
- 为解决上述问题，可将类的构造函数设置为protected，并提供public静态函数完成构造，将析构函数也设置为protected，这样派生类可以访问析构函数。
- 限制对象只创建在栈上，将operate new()设置为私有函数，

空类
- 空类声明时不会生成任何成员函数，编译器生成1字节占位符，确保实例化后每个实例都有独一无二的地址。
- 空类定义时会生成6各成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。sizeof(class)仍为1。

类的大小
- 指的是实例化后对象的大小，遵循结构体成员变量对其原则，与成员函数和静态成员无关。
- 虚函数对类的大小有影响，因为包含虚函数表指针；虚继承对类的大小有影响，因为包含虚基表指针。

final与禁止继承
- 使用final修饰的类不能被继承，使用final修饰的虚函数不能被重写。
- 使用友元、虚继承和私有构造函数使类不能被继承。

















