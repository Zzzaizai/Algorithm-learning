三大特性
- 继承，子类继承父类的非private成员变量和成员函数，若被final修饰则不能继承。
- 封装，将具体实现过程与数据封装成一个函数，只提供接口访问。
- 多态，动态决定调用哪个派生类的实现，一般使用虚函数实现。

重写、重载、隐藏
- 重载指的是同一可访问区内被声明几个具有不同参数的同名函数，根据参数决定调用哪个函数，不关心函数返回类型。
- 隐藏是指派生类的函数屏蔽了与其同名的基类函数，不管参数列表是否相同，基类函数都会被隐藏。可通过类型名知名访问基类函数。
- 重写指的是派生类存在重新定义的函数，函数名、参数列表、返回值类型必须与基类里被重写的函数一样，基类中被重写的函数必须有virtual修饰。
- 重写可以实现多态，隐藏不可以。

多态实现
- 基类函数前加上virtual修饰，在派生类中重写该函数，运行时将会根据对象的类型调用相应函数。
- 创建一个类时，该对象有一个指向虚函数表的虚表指针vptr，当基类指针指向派生类对象，基类指针调用虚函数时，该基类指针的虚表指针实际指向派生类的虚函数表。与this指针不同，this指针是编译器解析自引用的函数参数，vptr是一个真正的指针。
- 每个使用虚函数的类都有自己的虚函数表，编译器在编译时将其设置为静态数组vtable，此表中每个条目是一个函数指针。
- 如果未使用虚函数，则是普通的隐藏，则基类指针指向派生类对象时，使用的是基类的方法（与指针类型看齐）。

虚函数与纯虚函数
- 纯虚函数在类中声明时，用virtual修饰并加上=0，且没有函数的具体实现。
- 含有纯虚函数的类为抽象类。类中只有接口定义，没有实现。继承纯虚函数的派生类若没有实现基类中的纯虚函数，该派生类依然为抽象类，无法实例化对象，但可以声明抽象类指针与引用。
- 纯虚函数的意义在于让所有类的对象都可以要求实现纯虚函数。
- 析构函数最好定义为虚函数，否则当基类指针指向派生类对象时，对基类指针进行delete操作，只会调用基类的析构函数，造成内存泄漏。构造函数不能为虚函数，因为对象创建后才会产生虚表指针，才能调用虚函数。
- static函数不能定义为虚函数。

多重继承
- 多重继承容易产生命名冲突和数据冗余等问题，如菱形继承中就会产生命名冲突。
- 可以通过显示声明冲突的成员来自于哪个类来解决，也可通过虚继承的方法来解决。
- java、c#、php等语言都不支持多继承。

深拷贝与浅拷贝
- 如果一个类拥有资源，该类的对象复制时，如果资源重新分配就是深拷贝，否则就是浅拷贝。
- 该对象和原对象占用不同的内存，拷贝栈与堆中的内容，就是深拷贝；该对象和原对象占用一块内存，仅拷贝栈中的内容，就是浅拷贝。
- 当类中成员变量有指针时，最好使用深拷贝，因为当两个对象指向同一块内存，如果使用浅拷贝，其中一个对象删除后，该内存就被释放，另一个对象指向的就是垃圾内存。
- 编译器生成的默认拷贝函数大部分是浅拷贝，在特定场景下需要禁止编译器生成默认拷贝构造函数。
