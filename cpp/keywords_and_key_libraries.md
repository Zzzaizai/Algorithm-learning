sizeof与strlen
- sizeof测量的是对象或表达式类型占用的字节大小，在编译时计算。
- strlen测量的是字符串的实际长度，以\0结束，在运行时计算。

static
- 全局静态变量，限制了全局变量的作用域为当前源文件，只初始化一次。
- 局部静态变量，仅作用于函数内部，只初始化一次。
- 静态函数，限制函数的作用域为定义该函数的文件内部。
- 静态成员变量，相当于类域中的全局变量，只初始化一次，可以作为成员函数的参数，静态成员变量的类型可以是所属类的类型。
- 静态成员函数，不能调用非静态成员变量和非静态成员函数，没有this指针，作为类域的全局函数，不能声明成虚函数，长函数和volatile函数。
- 静态对象，生命周期为程序运行期间。

const
- const变量，可进行类型检查，节省内存提升效率，变量不可修改。
- const指针，```const int *p = &x;```指针指向的内容不可变；```int* const p = &a;```指针不可变。
- const引用，可指向const变量或非const变量，可读取变量但不能修改。
- const成员变量，只能在类内声明定义，在构造函数初始化列表中初始化，因为一个类可创建多个对象，const成员变量是不同的。
- const成员函数，不能修改只能访问成员变量，不能调用非常量成员函数，以防修改成员变量。
- const函数与返回值，const修饰函数参数时，函数内部不可修改

define/const
- define在预编译时进行替换，const在编译时确定值。
- define只进行简单的代码替换，不检查安全。
- define不占用内存，const占用静态存储区的只读空间。
- define接受参数构造非常复杂的表达式，const不接受参数。

inline
- 内联函数在调用时不通过函数调用机制而是直接在调用点处展开，大大减少由函数调用带来的开销。
- 类内定义的成员函数默认为内联函数。
- 类外定义成员函数，若想定义为内联函数需要使用inline关键字。
- inline关键字要和函数的定义放在一起，而不是声明。

内联函数工作原理
- 在编译阶段将函数体嵌入到每一个调用该函数的语句块中。
- 实际编译后，代码中仍存在内联函数的定义，也可以有指向它的指针。
- 节省了函数调用堆栈开销。
- 但在内联函数中添加变量会消耗额外的寄存器，若使用太多内联函数则会导致可执行文件变大，更改内联函数代码时，所有调用位置都要重新编译。
- 内联函数适用于简单函数，内敛只是对编译器的请求而不是命令，当函数包含循环、静态变量、递归、返回类型不是void且不存在return语句、包含switch或goto语句时，编译器可能忽略内敛请求。
- 内联函数在某个源文件中只能定义一次，在一个程序所有源文件中定义必须完全相同。一般在头文件中定义内联函数。

new/malloc
- malloc为c的库函数，当heap段不够时，会通过mmap映射新的物理内存到heap空间中并将新的物理内存映射到heap末尾，形成虚拟连续内存。
- new申请内存时会调用对象的构造函数进行初始化，可以重载。
- new可指定内存空间初始化对象，空间大小由编译器计算；而malloc只从堆中申请内存，大小需指定。
- new返回对象指针，malloc返回void *指针。
- malloc可以通过realloc重新指定空间大小，new一旦申请无法更改。
- new可以指定在内存地址空间创建对象。
- new可以重载，全局重载将所有的new操作都重写，局部重载就是在类中重写operator new函数，只对该类生效。

free/delete
- free释放heap中通过malloc，calloc，realloc申请的内存，需手动把指针置null。
- delete时若对象存在析构函数，则先执行析构函数，再释放内存。只能用来删除new出的内存，如果new的对象是指定地址，则不能使用delete。
- delete可重载。

volatile
- 使用volatile关键字阻止编译器过度优化，直接从变量地址中读取，常用于对象的值在程序控制或检测之外被改变时。
- 多线程并发访问共享变量时，使用volatile关键字修饰变量，可确保改变后的值对其他线程可见。

struct/class
- cpp中struct是抽象数据类型，支持成员函数定义。cpp中struct可以继承多态。
- class可实现struct所有功能，为兼容c保留了struct。
- class成员默认为private，继承默认为private；struct成员默认为public，继承默认为public。

struct/union
- union是联合体，所有成员变量共享同一段内存。
- 使用时，联合体只有一个有效的成员，对联合体不同成员赋值，将会覆盖其他成员的值。
- 联合体大小为其内部所有变量的最大值，按照最大类型的倍数分配；结构体内存大小遵循内存对齐原则。
- struct可以定义变长数组成员变量，union不可以。

extern C
- 由于cpp支持重载，因此编译后函数的名不仅是原始的函数名称，还有参数类型等；而在c中编译后的函数名不包括参数类型。
- 在cpp中调用c编写的模块中某个函数，会按照cpp修饰方法链接函数，因此会发生连接错误。
- 使用extern C声明后，在链接时会按照c命名规则查找函数。

strcpy
- strcpy时cpp的标准函数，把含有\0结束符的字符串复制到另一个地址空间，返回char *首地址。
- strcpy不检查目的缓冲区大小边界，逐一进行复制，会导致其他变量被覆盖。
- 利用strcpy特性可编写shellcode进行缓冲区溢出攻击，为保证安全，一般使用strncpy代替。

explicit
- 用来声明类构造函数是显式调用的，阻止构造函数进行隐式转换和复制初始化。
- 用于修饰单参数构造函数，因为无参和多参构造函数本身就是显式调用的。
- 一般情况下建议声明explicit的构造函数，放置编译器执行非预期的类型转换。

define/typedef
- define为预处理指令，只是简单的替换。
- typedef用来定义类型的别名，方便使用，有自己的作用域。

memmove
- 用于拷贝字节，当目标与源有重叠时，可保证源被覆盖之前拷贝至目标内。
- 若没有重叠，则memmove与memcpy作用相同。

auto原理
- 首先，如果初始化表达式为引用，则去除引用。
- 其次去除初始化表达式的const和volatile限定。
